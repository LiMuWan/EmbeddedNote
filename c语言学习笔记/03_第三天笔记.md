# 第三天笔记

## 1. 浮点类型

* 浮点类型包含:float-单精度浮点型 double-双精度浮点型 long double-长双精度浮点型

* float:单精度浮点型

  * 占4个字节,字面量值后面会有一个f ,比如:

    ```c
     float f1 = 10.123f;
     printf("%f ",f1);
    ```

  * 格式占位符: %f---浮点型的数据展示 ,%.2f--保留2位有效小数, %e---科学计数法 ,%.2e--保留2位有效小数的科学计数法

* double

  * 占8个字节,字面量值后面可以不用任何标识

    ```c
    double d = 12.234;
    printf("%lf",d);
    ```

  * 格式占位符:%lf--浮点型的数据显示,%.2lf--保留2位有效小数, %e---科学计数法 ,%.2e--保留2位有效小数的科学计数法

  * 如果使用scanf()接收double类型的数据,格式占位符必须使用%lf,printf()可以使用%f

* long double

  * 占16个字节,字面量值后面会有一个L

    ```
    long double ld = 12.123L;
    printf("%Lf",ld);
    ```

  * 格式占位符:%Lf--浮点型的数据显示,%.2Lf--保留2位有效小数, %Le---科学计数法 ,%.2Le--保留2位有效小数的科学计数法

  * 如果使用scanf()接收double类型的数据,格式占位符必须使用%Lf

## 2. 字符类型

* char 类型就是字符类型
  * char占1个字节
  
  * char 定义的变量 使用sizeof(变量) 结果也是1个字节
  
  * 但是char的字面量值直接使用sizeof(值)的字节是:4个,默认是int类型
  
  * char 定义的变量,里面存储的字符值,需要使用单引号进行包裹,但是也可以直接赋值一个整数
  
  * 使用%c格式占位符输出对一个的字符内容,也可以使用%d进行输出
  
  * 还有对应的转义符
  
  * ```
    \t
    \\
    \"
    \'
    \n
    \r
    ```
  
  * char ch = 'e';

## 3. 布尔类型

* 首先可以使用系统自带的_Bool 来定义变量,里面存储1(非0)的值或者0

* 布尔类型的值表示的是真或者假

* 也可以使用#define 的方式定义 布尔类型,这种方式属于宏定义

* 还可以引入stdbool.h这个库,使用bool来定义布尔类型的变量,并且赋值使用

  ```c
  // 方式1:
  _Bool b1 = 1;
  _Bool b2 = 0;
  _Bool b3 = -10; // 真
  // 方式2:
  #define BOOL int
  #define TRUE 1
  #define FALSE 0
  // 方式3
  #include <stdbool.h>
  bool b3 = true;
  bool b4 = false;
  ```
## 4. 计算字节sizeof

* sizeof 可以用来计算数据类型或者变量或者字面量值的字节数
* 使用方式:两种
* 方式1: sizeof(数据类型名字/变量名/字面量值)
* 方式2: sizeof 变量名/字面量值
%zu----是sizeof计算后的结果所需要的格式占位符    

## 5. 类型转换

* 类型转换:不同类型的数据要进行计算或者是赋值操作,此时会进行不同类型的一个转换操作

* 自动类型转换(隐式转换)(计算/赋值)和强制类型转换(显示转换)

* 运算的过程中进行转换和赋值的时候进行转换

  * 窄类型(所占的字节比较小,范围比较小)和宽类型(所占的字节比较大,范围比较大)之间的转换
* 自动类型转换(隐式转换):窄类型的数据由系统(编译器)自动转换成了宽类型的数据
  
  * 不会丢失精度
  * 强制类型转换(显示转换)，转换的过程中和编译器或者系统有一定的关系,个别的时候会出现警告信息,推荐我们使用强制转换的方式,无非就是在数据(变量/字面量的值)的前面使用小括号,括号中书写要转换的数据类型
* 宽类型的数据转窄类型的数据,会出现精度丢失的情况
  * 例子:

  ```
// 第一个情况
  int num = 10;
  double d = num ; // 赋值的时候出现了隐式转换,此时不会出现精度丢失问题
  // 下一个情况
  double d2 = 12.345;
  int num2 = d2; // 赋值的时候出现了强制类型转换,此时会出现精度丢失,系统中容易出现警告
  上面的方式推荐的写法
  double d3 = 12.345;
  int num3 =(int)d3; // 这种方式直接告诉编译器,给我转换int,不会出现警告
  ```
  
  

## 6. 运算符号

* 运算符:是符号,具有计算的一些能力
* 如果按照运算符所需的操作数分类:一元运算符,二元运算符,三元运算符
  * int num=10;num++
* 如果按照运算符的功能分类:算数运算符,关系运算符,逻辑运算符,赋值运算符,位运算,杂项运算符

## 7. 算数运算符

* 正号,负号加,减,乘,除,取余(取模),自加,自减

  ```
  正号 + 
  减号 -
  加  +
  减  -
  乘  *
  除  /    两个数(有可能是整数,也有可能是小数)相除的结果:需要多考虑一下,有可能是小数的结果,此时最好要提前进行一个类型的转换
  取余 %   两个数字取余的结果一定是整数,要注意第一个操作数的符号,和结果是有关系(一样),第一个数如果是负数,那么结果就是负数,如果第一个数是正数,那么结果就是正数
  	例子: -9%2 = -1 结果是负1
  自加 ++
  	分为:前加,后加
  	后加: int num=10; num++; 此时num先参与运算,然后再自身加1
  	前加: int num=10; ++num; 此时先加1,然后参与运算
  自减 --
  	分为:前减,后减
  	后加: int num=10; num--; 此时num先参与运算,然后再自身减1
  	前加: int num=10; --num; 此时先减1,然后参与运算
  ```

  

## 8. 关系运算符

* 等于,不等,小于,小于等于,大于,大于等于

  ```
  等于  ==
  不等  !=
  小于  <
  小于等于 <=
  大于 >
  大于等于 >=
  ```

* 由关系运算符连接起来的表达式,叫关系运算表达式,结果是布尔类型,值:要么是真(1/(非0)),要么是假(0)

## 9. 逻辑运算符

* 逻辑与,逻辑或,逻辑非

  ```
  逻辑与  &&   表达式: 表达式1&&表达式2
  逻辑与的整个表达式的结果,取决于两个表达式的结果
  如果表达式1和表达式2的结果都是真,则整个式子的结果就是真
  如果有一个表达式的结果是假,则整个式子的结果就是假
  短路: 如果第一个表达式的结果是假,则表达式2就不再参与运算了
  
  逻辑或  ||  表达式: 表达式1||表达式2
  逻辑或的表达式的结果,取决于其中的一个即可
  如果其中一个表达式的结果是真,则整个表达式的结果就是真
  如果两个表达式的结果都是假,结果一定是假
  短路: 如果第一个表达式的结果是真,则表达式2就不再参与运算了
  
  逻辑非  ! 表达式:    !表达式1
  表达式1的结果如果是真,则整个表达式的结果就是假,反之,为真
  
  ```

* 由逻辑运算符连接起来的表达式,叫逻辑运算表达式,结果是布尔类型,值:要么是真(1/(非0)),要么是假(0)

## 10. 赋值运算符

* 赋值符号,相加赋值符号,相减赋值符号,相乘赋值符号,相除赋值符号,取模赋值符号,按位与赋值符号,按位或赋值符号,按位异或赋值符号,左移赋值符号,右移赋值符号

  ```
  赋值符号:   =   符号右侧的内容赋值给符号的左侧
  普通的写法: 
  int a = 10;
  a = a +2; 普通的运算表达式的写法
  简写: a+=2; 下面的符号都属于简写
  复合赋值运算符
  相加赋值符号: +=   
  相减赋值符号: -=
  相乘赋值符号: *=
  相除赋值符号: /=
  取模赋值符号: %=
  左移赋值符号: <<=
  int a = 3;
  a<<=2; 
  结果的计算过程: 十进制的3转成二进制,然后按位向左移动2位
  简单算法: 3* 2^2   3*2的2次方
  
  右移赋值符号: >>=
  int a = 3;
  a>>=2; 
  结果的计算过程: 十进制的3转成二进制,然后按位向右移动2位
  简单算法: 3/2^2   3*2的-2次方
  
  按位与赋值符号: &=
  
  按位与:
  符号两边的数字要转成二进制的值,如果都是1,则结果是1,否则为0
  例子:
  int a=3,b=2;
  0000 0011
  0000 0010
  -----------
  0000 0010 
  
  按位或赋值符号: |=
  按位或:
  符号两边的数字要转成二进制的值,如果有1,则结果是1,否为0
  例子:
  int a=3,b=2;
  0000 0011
  0000 0010
  -----------
  0000 0011
  
  按位异或赋值符号: ^=
  
  按位异或:
  符号两边的数字要转成二进制的值,如果相同则为0,不同则为1
  例子:
  int a=3,b=2;
  0000 0011
  0000 0010
  -----------
  0000 0001
  
  ```
```
  
  






```