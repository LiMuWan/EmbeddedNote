# 第九天笔记

## 1. 指针

* 指针:就是指针变量,用来存储某个变量的 内存地址

* 指针:来指向内存地址的一个可移动的标识(可移动的标识,该标识指向的是某个内存地址)

* 指针变量 中存储的 是一个 变量的内存地址

* 指针变量 指向了一个 变量的 内存地址

* 指针(指针变量)的声明

  * 指针变量声明的基本语法: 数据类型 *指针变量名;   这种是先声明,后赋值

    ```
    例子:
    int num = 10; // 声明一个int类型的变量,起名为num,并赋值为10
    int *ptr; // 声明一个int*类型的指针变量,起名为ptr,
    // 为指针变量赋值
    ptr = &num; // 把num变量的 内存地址 存储到了 指针变量 ptr中
    // num中存储了数据值是10,num变量有自己的内存地址
    // ptr中存储了num变量的内存地址,该地址中的数据是10
    // & 符号 ----取地址符号   &num 把num的内存地址取出来
    // * 符号 ----解引用(间接运算符) *ptr 把ptr中存储的内存地址 对应 的数据取出来
    // 引用----指针(地址),解引用:解开这个引用(地址)中存储的东西---数据值
    // %p ---- 用来显示内存地址的
    ```

* 指针(指针变量)的声明

  * 指针变量声明并初始化的基本语法: 数据类型 *指针变量名 = &变量名;

    ```
    例子:
    int num = 10; // 声明一个int类型的变量,起名为num,并赋值为10
    // 声明了一个int*类型的指针变量,起名为ptr, 把num变量的 内存地址 存储到了 指针变量 ptr中
    int *ptr= &num; 
    // num中存储了数据值是10,num变量有自己的内存地址
    // ptr中存储了num变量的内存地址,该地址中的数据是10
    // & 符号 ----取地址符号   &num 把num的内存地址取出来
    // * 符号 ----解引用(间接运算符) *ptr 把ptr中存储的内存地址 对应 的数据取出来
    // 引用----指针(地址),解引用:解开这个引用(地址)中存储的东西---数据值
    ```

## 2. 指针运算

* 指针运算 : 指针变量的运算,由于指针变量中存储的是内存地址,其实指针运算,就是内存地址的运算(也会涉及到内存地址对应的内存空间中的数据的运算)

* 指针运算指的是:指针可以进行加减操作

  * 指针的加减操作,其实就是在让指针进行移动,要么向后移动,要么向前移动

  * 指针在移动的时候,每次移动的是n个字节,n和当前指针变量的类型是有关系,如果加的是一个整数,我们就说该指针向后移动了1个单位,也就是4个字节

  * 例子:

    ```
    int num = 10;
    int *ptr = &num;
    ptr = ptr+1; // 简写: ptr+=1;
    ```

  * 指针移动的单位计算

    ```
    int *ptr1;
    ptr1+=1; // 移动了一个单位,是4个字节
    
    char *ptr2;
    ptr2+=1; // 移动了一个单位,是1个字节
    
    short *ptr3;
    ptr3+=1; // 移动了一个单位,是2个字节
    
    double *ptr4;
    ptr4+=1; // 移动了一个单位,是8个字节
    
    例子:
    int *ptr5;
    ptr5+=5; // 移动了5个单位,是20个字节
    ```

* 指针移动,每次移动的是n个单位,指针变量是可以进行加或者减的操作,并且修改了自己的指向地址的

  * 例子:

    ```
    int *ptr= &num;
    ptr+1; // ptr指针变量的指向地址没有变化
    ptr+=1; // ptr指针变量的指向地址有发生变化
    ```

* 指针变量可以加减操作:指针变量指向的内存地址,该指针的指向是可以改变的 

* 指针进行加的操作:向后移动 指针变量的 指向
* 指针进行减的操作:向前移动 指针变量的 指向
* 指针进行加加和减减操作:指针变量自身是可以改变指向的
* 变量的内存地址可以进行加和减的操作,但是自身的指向不能改变
* 指针变量可以+1,可以-1,可以++,可以--,但是变量的内存地址是不允许++,--,但是可以+1,可以-1
* 同类型指针相减的结果是正数,是相差了几个元素个数
  * 同类型的指针相减,也就是低位的地址和高位的地址,相互 相减
  * 上面的相减,指的是要么是低位减高位,要么是高位减低位
  * 低位减高位结果是负数
  * 高位减低位结果是正数
  * 其实高低位相减的结果是得到了当前指针数据类型的字节数,需要把字节数除以数据类型的字节数,得到的是整数(元素的相差个数)
* 指针之间可以进行比较运算 == , !=, >, >= ,< ,<= 
* 低位指针和高位指针进行比较,比较谁大,结果是布尔类型(真/假)

## 3. 指针和数组

* 数组的理解

  * 数组是用来存储一些数据的组合

  * 定义:数据类型 数组名[长度]={元素值1,元素值2,元素3...};

    ```
    int nums[3]={10,20,30};
    printf("%d \n",nums[0]); // 通过数组名和索引进行组合 获取下标为0位置的数据
    此时nums是数组
    sizeof nums 计算的整个数组的总的字节数
    int a = nums[0]; // 通过数组名和索引进行组合 获取下标为0位置的数据，并赋值给变量a
    ```

* 数组中可以存储指针

* 指针数组:是一个数组,里面存储的是指针(指针变量)

  * 指针数组的定义的基本语法: 数据类型 * 指针数组名[长度]={指针变量1,指针变量2,指针变量3...};

    ```
    int a=10,b=20,c=30;
    int *ptr_arr[3]={&a,&b,&c};
    ptr_arr是指针数组
    ptr_arr的类型是: int *[3];
    // 遍历数组
    for(int i=0;i<3;i++){
       printf("%p===%d \n",ptr_arr[i],*ptr_arr[i]);
    }
    ```

* 指针可以指向数组

* 数组指针:是一个指针变量,指向了一个数组的内存地址

* 数组指针的声明语法: 数据类型 (*数组指针变量名)[长度]=&数组名;

* 普通的指针变量: 数据类型 *指针变量名=数组名

* 普通的指针变量: 数据类型 *指针变量名=&变量名

  ```
  int num = 10; // 变量
  int *ptr1 = &num; // ptr1 int *类型的指针变量(普通变量)
  int arr[3]={10,20,30};
  int (*ptr)[3]=&arr;
  ptr++;
  int *ptr2 = arr;
  // arr是数组,
  // arr的到的是自己的内存地址/数组中第一个元素的内容地址,
  // 由于arr的内存地址和第一个元素的内存地址一样,所以,arr此时也可以当成第一个元素的内存地址使用
  int *ptr2 = arr;  // 此时的ptr2是普通的指针变量,
  ptr[0]
  ```

```c
#include <stdio.h>  // 数组指针的理解
int main()
{
  // int num = 10;
  // int a = 100;
  // &num+1;
  int arr[] = {10,20,30,40};
  int *ptr = arr;
  // printf("%d \n",ptr[0]); // ptr当成数组名来用
  // printf("%d \n",*(ptr++)); // ptr不是数组名,此时是把arr中的内存地址当成数组中第一个元素的内存地址使用的(ptr变量只是指向了那个内存地址的位置,ptr++,在改变的自身的指向,但是数组中第一个元素的内存地址没有变化)
  // printf("%d \n",*(ptr++)); // ptr不是数组名
  // printf("%d \n",*(arr+1)); // 此时arr还是取出了内存地址,当成第一个元素的内存地址使用

  int(*ptr_arr)[4] = &arr;
  // printf("%d \n",(*ptr_arr)[0]);
  printf("%p \n",ptr_arr);
  printf("%p \n",ptr_arr+1);

  return 0;
}
```

* 数组的理解:

  ```
  int nums[3]={10,20,30};
  nums 是数组名,存储的是第一个元素的内存地址
  &nums 直接获取数组自己的内存地址
  ```

## 4.字符指针

字符指针:就是一个指针,指向的是字符/字符数组/字符串的内存地址

字符数组:就是一个数组,里面存储的是多个字符/字符串

字符指针中存储的字符串,可以看成是字符数组,可以通过for循环遍历,使用索引的方式访问每个字符

字符数组可以看成是字符串,也可以使用%s占位符进行输出

字符指针可以改变指向,可以重新赋值(重新开内存空间),不可以通过索引修改里面的数据

字符数组不可以改变指向,但是可以通过索引的方式修改里面的数据

## 5. 指针和函数

* 函数:用来封装一些重复代码的,函数有参数,有返回值,有函数名字,有函数体

* 函数分为:系统函数和自定义函数(先声明后调用)

* 指针:指针变量,指向某个 内存地址

* 指针可以作为函数的参数使用,也可以作为函数的返回值使用

* 指针函数:是一个函数,返回值是一个指针

  ```
  例子:
  int get_sum(int a,int b){
     return a+b; // 计算的结果
  }
  // 指针函数:就是把指针作为函数的返回值使用
  int * get_sum(int a,int b){
  	// int sum = a+b;
  	// return &sum; // 此时代码可以这么书写,但是运行的时候会报错
  	static int sum; // 先声明,一个静态的局部变量(全局的静态区)
  	sum = a+b; // 为局部变量赋值
  	return &sum; // 返回静态局部变量的内存地址
  }
  // 把指针作为函数的参数使用
  void show_num(int *a){
    *a +=100; // 通过解引用指针变量,获取指向的内存地址对应空间中的数据,进行修改
  }
  int num = 10;
  show_num(&num);
  printf("%d \n",num); // 110;
  ```

  

* 函数指针:是一个指针变量,指向了一个函数的内存地址

* 函数指针的声明语法: 数据类型(*函数指针变量名)([参数列表]);

* 例子:

  ```
  函数指针:
  int get_max(int a,int b){
    return a>b?a:b;
  }
  int (*ptr_get_max)(int a,int b)= &get_max;
  // 使用函数指针
  int (*ptr_get_max)(int a,int b)= get_max;
  // 简写
  int (*ptr_get_max)(int,int)= get_max;
  // ptr_get_max就相当于get_max
  // get_max求和
  int sum1 = get_max(10,20); // 求和 普通函数调用方式
  int sum2 = ptr_get_sum(100,200) // 求和 使用的是函数指针的方式
  ```

* 通过函数指针,可以调用不同的函数实现计算或者数据运算的操作

* 回调函数:也是函数,只不过,把这个函数当成参数使用,在另一个函数内部调用这个函数

* 回调函数:函数A作为另一个函数B的参数使用,此时该函数A就是回调函数,也就是将来要在函数B中进行调用(函数A调用)

* 例子:

  ```
  例子:
  int get_num(int a){
    return a*2;
  }
  void init_array(int *ptr_arr,int len,int(*callback)(int)){
  	for(int i=0;i<len;i++){
  	   *(ptr_arr+i) = callback(ptr_arr[i]);
  	}
  }
  main(){
  int arr[3]={1,2,3};
    init_array(arr,3,get_num);
  }
  ```

  



## 6. const指针和指针const

* const 指针 的定义方式:

* const 数据类型 * 指针变量名= &变量名;

* 数据类型 const * 指针变量名= &变量名;

* const 指针特点:指向可以改变,但是指向的内存地址对应的空间中的数据值不可更改

  ```
  int num = 10;
  const int *ptr = &num;
  // 另一个写法
  // int const *ptr2 = &num;
  // *ptr+=100; // 改值--不能改,报错
  int num2 = 20;
  ptr=&num2; // 指向是可以改变
  ```

* 指针const的定义方式:

* 数据类型 * const 指针变量名 = &变量名;

* 指针const 特点: 指向不可改变,指向的内存地址对应的空间中的数据可以改变

```
int num = 10;
int *const ptr = &num;
*ptr+=100; // 可以修改值的
int num2 = 20;
ptr=&num2; // 指向是不可以改变的
```



## 7. 多级指针

* 指针分为:一级指针,二级指针,三级指针.....只要是超过一级指针的,都是多级指针

* 多级指针的定义方式及使用

  ```
  例子:
  int num = 10;
  int *ptr1 = &num ; // ptr1是 一级指针变量
  int **ptr2 = &ptr1; // ptr2是 二级指针变量
  int ***ptr3 = &ptr2; // ptr3是 三级指针变量
  
  ```

  



## 8. 空指针和野指针

* 空指针:指针变量指向了NULL ,此时就是空指针,建议每个指针变量在声明的是时候都要进行初始化

  ```
  如: int *ptr = NULL; // 此时ptr是空指针
  ```

* 野指针:指针变量指向了其他的内存地址:不受我们控制

* 如:

* 声明指针变量的时候,没有初始化

  ```
  例子:
  int *ptr; // 野指针
  ```

* 指针变量越界了

  ```
  int arr[]={10,20};
  int *ptr =&arr[5]; // 此时是越界的
  ```

  

* 指针变量指向了一个已经释放的内存地址

  ```
  int * get_num(int a){
    return &a;
  }
  int main(){
  int *ptr =get_num(10);
  }
  ```

  

## 指针

### 1. 指针的概念

* 指针:指的是指针变量,指向的是变量/常量/数组/函数/结构体变量等的内存地址
* 指针:用来指向内存地址的一个可移动的标识

### 2. 指针变量所占的字节数

* 使用sizeof关键字(运算符)来计算指针变量的内存地址所占的字节数,目前,所占的字节数是:8个

### 3. 指针的运算

* 指针可以进行整数加减运算

  * 如果加一个整数n,自身的值没有改变,表示向后移动n个单位(对应数据所占字节数*n)
  * 如果减一个整数n,自身的值没有改变,表示向前移动n个单位(对应数据所占字节数*n)

* 指针可以进行赋值整数运算

  * 如果进行相加赋值,或者加一个整数再赋值,那么自身的值改变了,表示向后或者向前移动n个单位

    * ```c
      int nums[]={10,20,30,40,50};
      int *ptr =&nums[0];
      ptr+1 ;  // 向后移动1个单位,自身值不变
      ptr+=1; // 向后移动1个单位,自身值改变
      ptr = ptr+1; // 向后移动1个单位,自身值改变
      ptr-1; // 向前移动1个单位,自身值不变
      ptr-=1; // 向前移动1个单位,自身值改变
      ptr=ptr-1; // 向前移动1个单位,自身值改变
      ```

* 指针可以进行自增或自减运算

  * 指针自增或者自减表示向后或者向前移动1个单位,自身的值改变了

    * ```c
      int nums[]={10,20,30,40,50};
      int *ptr =&nums[0];
      ptr++;// 向后移动1个单位,自身值改变
      ptr--; // 向前移动1个单位,自身值改变
      ```

* 指针之间可以进行相减运算

  * 指针之间相减得到的是相差的元素个数(字节数计算)

    * ```c
      int nums[]={10,20,30,40,50};
      int *ptr1 =&nums[0];
      int *ptr2 = &nums[3];
      ptr1-ptr2; // 结果是:-3 相差了3个元素
      ptr2-ptr1; // 结果是3   相差了3个元素
      ```

    * 

* 指针之间可以进行比较运算

  * 指针之间可以进行 == < <= > >= 的运算,其结果是布尔类型:true或false

### 4. 指针和数组的关系

* 指针数组:就是一个数组,里面的每个元素都是指针(每个元素都是一个内存地址/每个元素都是指向了变量的内存地址)

  * 指针数组的声明或定义: 数据类型 * 指针数组名[长度]={指针1,指针2,指针3,...};

  * 指针数组的类型: 数据类型*[长度];

    * ```
      int num1=10,num2=20,num3=30;
      int * ptr_arr[3]={&num1,&num2,&num3};
      // ptr_arr的类型是:   int *[3]
      ```

* 数组指针:就是一个指针,指向了数组的内存地址

  * 数组指针的声明或定义: 数据类型 (*数组指针名)[长度] = &数组名;

  * 数组指针的类型: 数据类型(*)[长度];

    * ```
      int nums[]={10,20,30};
      int (*arr_ptr)[3] = &nums; // 长度:3  必须要有的
      // arr_ptr的类型是: int (*)[3];
      arr_ptr++; // 如果没有长度的设定, 这行代码会报错
      数组指针加1,或者数组指针自增,或者数组指针加等于1
      arr_ptr+1; // 自身值不变
      arr_ptr++; // 自身值改变
      arr_ptr+=1; // 自身值改变
      上面的这三行代码都是向后移动一个单位(整个数组的总字节数)
      &nums+1; // 自身值不变
      &nums++; // 不行的
      &nums+=1; // 不行的
      // 原因:如果自身值改变就意味着自身的指向发生了变化,也就意味着长度是可以改变,而c中数组一旦声明长度确定后,是不能改变
      
      ```

  * 指针和数组的关系:数组是指针吗?不是,指针是数组吗?不是

  * 指针是可以指向数组的内存地址的,该指针的指向是可以改变的,指针也可以指向数组中某个元素的内存地址,该指向也可以改变

  * 数组名中虽然有内存地址,指的是数组中第一个元素的内存地址,该指向不能改变

  * 如果是&数组名,此时得到的是数组的内存地址,该指向也是不能改变的

  * &数组名中的内存地址和数组名的内存地址虽然一样,但是意义不同,前者需要使用数组指针进行存储,后者使用普通指针进行存储,二者进行加1操作,结果不同,前者移动的是整个数组的总字节数,后者是向后移动一个数组元素的单位

  * sizeof在计算指针变量的时候得到的是内存地址所占的字节数

  * sizeof直接计算数组名得到的是数组总字节数

    * ```
      int nums[]={10,20,30};
      nums----->存储的是10这个数组的内存地址,和&nums[0]等价
      int *ptr1 = nums; // 和 int *ptr2 = &nums[0]; 等价  普通指针
      int (*ptr3)[3]=&nums; // 数组指针,指向的是数组的内存地址
      ptr1+1; // ptr1+=1; ptr1++; 移动了20这个位置的内存地址
      ptr3+1; // ptr3+=1; ptr3++; // 移动了12个字节---1个单位,最后指向的是数组越界的位置的地址
      &nums[0]+1; // 可以的
      &nums[0]++; // 不行的
      &nums[0]+=1; // 不行的
      nums+1; // 可以的
      nums++; // 不行的
      nums+=1; // 不行的
      &nums+1; // 可以的
      &nums++; // 不可以的
      &nums+=1; // 不可以的
      ```


