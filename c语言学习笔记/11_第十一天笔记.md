# 第十一天笔记



## 1. 共用体数据类型

* 共用体:自定义数据类型

* 语法: union 类型名字{成员1;成员2;}

  例子:

  ```
  union Data{
    char c;
    int a;
    float f;
  };
  // 变量的声明
  union Data dt;
  ```

* 变量的声明三种方式:

  ```
  方式1:
  union Data{
     char c;
     int a;
  };
  // 变量的声明
  union Data dt;
  方式2:定义数据类型的同时直接声明变量
  union Data{
     char c;
     int a;
  }dt;
  方式3:定义数据类型的同时省略类型名字直接声明变量
  union {
     char c;
     int a;
  }dt;
  dt.a=10;
  dt={.c='A'};
  dt={10};
  ```

* 共用体的成员赋值的时候,同一时间只能使用一个



## 2. typedef 起别名的

* 为基本数据类型起别名

  ```
  typedef int Integer;
  Integer num = 10;
  
  typedef int Bool;
  ```

* 为数组类型起别名

  ```
  int num[3]={10,20,30};
  typedef int Array[3]; 
  Array arr={10,20,30};
  ```

* 为指针类型起别名

  ```
  char * ptr_ch;
  typedef char * String;
  String str="1231eqewq";
  ```

* 为结构体起别名

  ```
  typedef struct Node1{
  	int *data;
  }Node2; // Node1是类型名,Node2是别名
  
  typedef struct {
  	int *data;
  }Node; // 此时的Node是别名,也可以是类型名
  ```

  



## 3. 动态内存分配

* 之前使用的相关数据类型,以及声明变量都是系统自动的分配内存空间

* 我想自己使用某个数据类型及对应的变量,自己动态的分配内存空间

* 系统提供的库: stdlib.h

* 四个基本的分配内存空间的函数: malloc函数,calloc函数,realloc函数,free函数

* malloc函数

  ```
  void * malloc(字节数量); 返回值是任意类型的指针,参数,要分配的内存空间的字节大小
  int * ptr = (int *)malloc(sizeof(int));
  ```

* calloc函数

  ```
  void * calloc(参数的个数,每个元素的字节数); 返回值是任意类型的指针,参数,要分配的内存空间的字节大小
  int ptr* = (int *)calloc(len,sizeof(int));
  该函数成功分配内存空间后,该空间中的数据默认是0;
  ```

* realloc函数

  ```
  void * realloc(需要重新分配内存空间的指针,字节数*2); 返回值是任意类型的指针,参数,要分配的内存空间的字节大小
  int ptr* = (int *)realloc(ptr,sizeof(int)*len*2);
  重新分配的内存空间的内存地址,有可能会和之前的内存地址一样,也有可能不一样(扩容的情况)
  容量变小:一般情况内存的地址和原来一样
  ```

* free函数

  ```
  free(要释放的指针变量); 没有必要进行二次释放
  既然已经释放过,就不要再继续使用了
  ```

  

* void 类型

  * void类型是任意类型,可以和任意类型进行相互转换
  * 其他类型转void类型,可以是隐式转换(默认行为)
  * void类型转其他类型,也可以是隐式转换(默认行为)
  * 平时我们比较推荐,void类型转其他类型的时候建议使用显示转换(强转)

## 4. 预处理相关的命令

* 预处理有对应的预处理器,在编译之前执行
* \# 开头的指令
* #include 引入头文件
* #define 宏定义,用来定义 宏
  * 注意: 结尾没有分号,属于纯替换
  * 可以定义数据类型
  * 可以进行嵌套
  * 但是不建议放在main函数中