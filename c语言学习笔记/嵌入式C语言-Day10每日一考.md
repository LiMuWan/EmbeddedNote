##### 1.【问答题】指针数组和数组指针有什么不同

```
指针数组:就是一个数组,里面存储的所有的数据是指针/指针变量/内存地址
指针数组的声明:
数据类型 * 指针数组名[长度];
例如: 
int num1 = 10;
int num2 = 20;
int num3 = 30;
int *ptr_arr[3]; 先声明后赋值
ptr_arr[0] = &num1;
ptr_arr[1] = &num2;
ptr_arr[2] = &num3;
声明的同时直接赋值
int *ptr_arr2[3]={&num1,&num2,&num3};
ptr_arr 的类型  int*[3];
ptr_arr2 的类型 int*[3];
指针数组中的数据是可以通过for循环进行遍历,里面的每个元素都是内存地址,如果需要输出数据,还需要进行解引用


数组指针：就是一个指针,指向了数组的内存地址
数组指针声明: 数据类型(*数组指针名)[长度];
例如:
int nums[]={10,20,30};
int(*arr_ptr)[3] = &nums;
nums[0]---获取的是数组中的第一个元素
&nums[0]---获取的是数组中第一个元素的内存地址
nums-----获取的也是数组中第一个元素的内存地址
*nums----数组中第一个元素的数据值
&nums----数组的内存地址
arr_ptr指向了数组的内存地址(&nums)
&nums 和 nums 和 &nums[0]  得到的内存地址是相同的
&nums[0]+1 向后移动一个单位,其结果就是第二个元素的内存地址
nums+1 向后移动一个单位,其结果也是第二个元素的内存地址
&nums+1 向后移动一个单位,其结果是数组总字节数后面的那个内存地址,属于越界的内存地址

&nums[0]+1 和nums+1 和&nums+1 其本身的值是没有改变的,而已没有改变任何的指向(其指向没有改变)
&nums[0]+=1 和nums+=1 和&nums+=1 都是不允许的,这意味着是在改变内存地址的数据值(在改变其指向),不允许的
&nums[0]++ 和nums++ 和&nums+= 都不可以(也会改变其指向),不允许的
arr_ptr是数组指针,可以arr_ptr+1(没有改变其指向)   都改变了指向:arr_ptr+=1 arr_ptr++/arr_ptr-- 都可以
arr_ptr指向可以改变,也可以指向其他的同类型的数组的内存地址
arr_ptr+1/arr_ptr++/arr_ptr+=1 都是向后移动一个单位(数组的总字节数)

指针数组是数组,数组指针是指针,二者完全不同

```



##### 2.【简答题】什么是指针函数？什么是函数指针？

​	

```
指针函数:就是一个函数,该函数的返回值是一个指针
例如: 
int* func1(int x,int y){} 就是一个指针函数
func1函数的类型 :   int *(int x,int y) 或者  int *(int,int)
指针函数内部应该返回的是一个指针(也可以理解为返回的是一个内存地址)
注意:函数内部是不能直接返回一个局部变量的内存地址的,如果要返回,需要把局部变量使用static进行修饰
其原因:static修饰的局部变量会在函数调用的第一次进行初始化,存储在全局静态区,直到程序结束后才销毁
指针也是可以作为函数的参数进行使用的


函数指针:就是一个指针,指向的是函数的内存地址
函数指针的声明语法: 返回值数据类型 (*函数指针名)(参数列表)
例如:
int func2(int x,int y){}
func2是函数名,可以直接获取其内存地址
&func2也可以获取其内存地址
函数指针定义
int (*func_ptr1)(int x,int y) = &func2;  // func_ptr1 的类型  int(*)(int x,int y);
或者
int (*func_ptr2)(int x,int y) = func2;   // func_ptr1 的类型  int(*)(int ,int );
或者
int (*func_ptr3)(int,int) = func2;
由于函数指针指向的是函数的内存地址,所以,可以通过函数指针调用其函数
func2(1,2); // 通过函数名调用函数
func_ptr1(1,2) ; // 通过函数指针调用函数
func_ptr2(1,2); // 通过函数指针调用函数
func_ptr3(1,2); // 通过函数指针调用函数
或者
(*func_ptr1)(1,2); // 解引用函数指针的方式调用函数
函数指针不仅可以调用函数,同时也可以实现回调函数的调用
回调函数:函数A作为另一个函数B的参数使用,在该函数B内部去调用这个函数A,此时这个函数A就是回调函数
函数如果作为另一个函数的参数使用,需要在函数定义的时候其参数列表中使用函数指针来确定要调用的函数的类型

指针函数是函数,函数指针是指针
```







##### 3. 【代码题】写出下面程序的运行结果

```C
int arr[5] = {10, 20, 30, 40, 50};
int *ptr1 = &arr[0];	// 	ptr1指向的是第一个元素的内存地址
int (*ptr2)[5] = &arr;  // ptr2指向的是数组的内存地址
printf("%s", (arr+1 == ptr1+1) ? "AAA " : "aaa ");		//   AAA
printf("%s", (arr+1 == ptr2+1) ? "BBB " : "bbb ");      //   bbb
printf("%s", (&arr+1 == ptr1+1) ? "DDD " : "ddd ");		//   ddd
printf("%s", (&arr+1 == ptr2+1) ? "EEE " : "eee ");		//   EEE 
```

##### 4.【代码题】请写出下面程序的运行结果

```C
void func(int arg1, int *arg2){
    arg1 += 1;  // 	11
    *arg2 += 1;  // 11
}
int main(){
    int num1 = 10, num2 = 10; // 局部变量
    func(num1, &num2); // num1是属于值传递, num2是属于引用传递(传递是引用/地址)
    printf("%d %d", num1, num2); // 10 11
    return 0;
}
```

##### 5. 【代码题】请写出下面程序运行结果？

```c
int sum(int a, int b){
    return a + b;
}
int func(int a, int b, int (*cb)(int, int)){
    return cb(a, b) / 2;
}
printf("%d", func(100, 200, sum)); // 150
```

